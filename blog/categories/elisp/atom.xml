<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: elisp | Tieh Kai Woo's Blog]]></title>
  <link href="http://cheunghy.github.io/blog/categories/elisp/atom.xml" rel="self"/>
  <link href="http://cheunghy.github.io/"/>
  <updated>2014-10-12T21:07:50+08:00</updated>
  <id>http://cheunghy.github.io/</id>
  <author>
    <name><![CDATA[Tieh Kai Woo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[elisp的跳转和导航]]></title>
    <link href="http://cheunghy.github.io/blog/2014/09/12/jump-and-navigation/"/>
    <updated>2014-09-12T15:38:29+08:00</updated>
    <id>http://cheunghy.github.io/blog/2014/09/12/jump-and-navigation</id>
    <content type="html"><![CDATA[<h3>直接跳转</h3>

<p>在光标下，M-x find-function
可以将这个绑定到一个快捷的按键。</p>

<h3>imenu</h3>

<p>多数mode都支持imenu来跳转到指定函数定义处。
M-x imenu</p>

<h3>用occur来概览</h3>

<p>M-x occur
它会生成一个新的buffer，给出所有匹配。在elisp模式下，用occur搜索defun，会得到一个函数定义的概览。</p>

<h3>使用hs-minor-mode来折叠代码</h3>

<p>使用hs-minor-mode可以折叠和展开。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[let and let*]]></title>
    <link href="http://cheunghy.github.io/blog/2014/09/11/let-and-let-star/"/>
    <updated>2014-09-11T13:43:28+08:00</updated>
    <id>http://cheunghy.github.io/blog/2014/09/11/let-and-let-star</id>
    <content type="html"><![CDATA[<h3>什么是变量绑定？</h3>

<p>先看一段代码。
``` lisp
(let* ((this-dir (file-name-directory (or load-file-name buffer-file-name)))</p>

<pre><code>   (util-dir (file-name-as-directory (expand-file-name "util" this-dir)))
   (inf-ruby-dir (file-name-as-directory (expand-file-name "inf-ruby" util-dir)))
   (jump-dir (file-name-as-directory (expand-file-name "jump" util-dir))))
</code></pre>

<p>  (dolist (dir (list util-dir inf-ruby-dir jump-dir))</p>

<pre><code>(when (file-exists-p dir)
  (add-to-list 'load-path dir))))
</code></pre>

<p>```
它有这样的格式：(let VARLIST BODY&hellip;)，说得容易理解就是这样：
(let ((varname value) (varname value)&hellip;)
  (body1)
  (body2)&hellip;)
这些被绑定的变量是在这个let之内的，一旦let中的语句执行完，就不见了，不会造成变量名污染。</p>

<h3>let 和 let* 的异同。</h3>

<p>let和let*在elisp中，都是局部变量绑定。不同的是，let是平行绑定（parallel binding），let*是顺序绑定。</p>

<p>例子如下：
<code>lisp
(setf x 'outside)
(let ((x 'inside) (y x)
  (list x y))
  ;输出结果为(INSIDE OUTSIDE)
(let* ((x 'inside) (y x)
  (list x y))
  ;输出结果为(INSIDE INSIDE)
</code></p>
]]></content>
  </entry>
  
</feed>
